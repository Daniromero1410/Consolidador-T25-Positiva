# -*- coding: utf-8 -*-
"""ELT CONSOLIDADOR T25 CON ML.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tfR8toytBngUr4s8G71DwHeThtuDVMHc
"""

# Commented out IPython magic to ensure Python compatibility.
# #@title 1.1 Instalar Dependencias { display-mode: "form" }
# 
# %%capture
# !pip install pandas openpyxl xlsxwriter tqdm xlrd chardet scikit-learn numpy
# 
# print("‚úÖ Dependencias instaladas correctamente")

#@title 1.2 Importar Librer√≠as { display-mode: "form" }

import pandas as pd
import numpy as np
import re
import warnings
import os
import gc
import io
import zipfile
import chardet
from datetime import datetime
from typing import Tuple, Optional, List, Dict, Any
from tqdm.notebook import tqdm
from google.colab import files
from IPython.display import display, HTML

# Machine Learning
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from collections import Counter

# Configuraci√≥n
warnings.filterwarnings('ignore')
pd.set_option('display.max_columns', None)
pd.set_option('display.max_colwidth', 60)
pd.set_option('display.float_format', lambda x: f'{x:,.2f}')

print("="*70)
print("üß† ETL CONSOLIDADO T25 - EDICI√ìN MACHINE LEARNING")
print("="*70)
print(f"üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print("‚úÖ Librer√≠as cargadas correctamente")

#@title 2.1 Clasificador Inteligente de Texto { display-mode: "form" }

class ClasificadorTextoMedico:
    """
    Clasificador ML para detectar si un texto es:
    - Manual tarifario (SOAT, ISS, PROPIO)
    - Descripci√≥n de procedimiento m√©dico
    - Porcentaje o valor num√©rico
    """

    # Vocabulario de referencia para manuales tarifarios
    VOCABULARIO_MANUAL = [
        'SOAT', 'SOAT VIGENTE', 'SOAT UVT', 'SOAT UVB', 'TARIFARIO SOAT',
        'ISS', 'ISS 2001', 'ISS2001', 'TARIFARIOS ISS', 'TARIFA ISS',
        'TARIFA PROPIA', 'TARIFAS PROPIAS', 'PROPIA', 'PROPIO', 'PROPIAS',
        'INSTITUCIONAL', 'TARIFAS INSTITUCIONALES', 'TARIFA INSTITUCIONAL',
        'DECRETO 2423', 'DECRETO 2644', 'UVT', 'UVB', 'TARIFA PLENA',
        'MENOS', 'PLENO', 'VIGENTE', 'MANUAL TARIFARIO'
    ]

    # Vocabulario de procedimientos m√©dicos
    VOCABULARIO_MEDICO = [
        'CONSULTA', 'TERAPIA', 'NEURAL', 'CIRUGIA', 'PROCEDIMIENTO',
        'TRATAMIENTO', 'EVALUACION', 'VALORACION', 'DIAGNOSTICO',
        'EXAMEN', 'BIOPSIA', 'ECOGRAFIA', 'RADIOGRAFIA', 'TOMOGRAFIA',
        'RESONANCIA', 'LABORATORIO', 'HEMOGRAMA', 'CURACION', 'SUTURA',
        'INYECCION', 'APLICACION', 'NEBULIZACION', 'HOSPITALIZACION',
        'CONTROL', 'SEGUIMIENTO', 'ESPECIALISTA', 'MEDICINA', 'GENERAL',
        'PEDIATRIA', 'GINECOLOGIA', 'ORTOPEDIA', 'CARDIOLOGIA', 'NEUROLOGIA',
        'PSIQUIATRIA', 'PSICOLOGIA', 'FISIOTERAPIA', 'FONOAUDIOLOGIA',
        'ODONTOLOGIA', 'OPTOMETRIA', 'ANESTESIA', 'URGENCIA', 'AMBULANCIA',
        'SANGRE', 'ORINA', 'GLUCOSA', 'COLESTEROL', 'TRIGLICERIDOS',
        'ELECTROCARDIOGRAMA', 'ENDOSCOPIA', 'COLONOSCOPIA', 'MAMOGRAFIA',
        'QUIMIOTERAPIA', 'RADIOTERAPIA', 'DIALISIS', 'TRASPLANTE', 'PROTESIS',
        'IMPLANTE', 'REHABILITACION', 'TERAPIA OCUPACIONAL', 'TERAPIA FISICA',
        'CONSULTA DE', 'VISITA DE', 'ATENCION DE', 'SERVICIO DE'
    ]

    def __init__(self):
        """Inicializa el clasificador y entrena el vectorizador."""
        # Crear corpus de entrenamiento
        self.corpus_manual = self.VOCABULARIO_MANUAL
        self.corpus_medico = self.VOCABULARIO_MEDICO

        # Entrenar vectorizador TF-IDF
        self.vectorizer = TfidfVectorizer(
            analyzer='char_wb',
            ngram_range=(2, 4),
            lowercase=True,
            max_features=1000
        )

        # Entrenar con todo el vocabulario
        todo_corpus = self.corpus_manual + self.corpus_medico
        self.vectorizer.fit(todo_corpus)

        # Vectores de referencia
        self.vec_manual = self.vectorizer.transform(self.corpus_manual)
        self.vec_medico = self.vectorizer.transform(self.corpus_medico)

        # Centroide de cada clase
        self.centroide_manual = np.asarray(self.vec_manual.mean(axis=0)).flatten()
        self.centroide_medico = np.asarray(self.vec_medico.mean(axis=0)).flatten()

        print("‚úÖ Clasificador ML entrenado")
        print(f"   ‚Ä¢ Vocabulario manual: {len(self.corpus_manual)} t√©rminos")
        print(f"   ‚Ä¢ Vocabulario m√©dico: {len(self.corpus_medico)} t√©rminos")

    def clasificar(self, texto: str) -> Dict[str, Any]:
        """
        Clasifica un texto y retorna probabilidades.

        Returns:
            Dict con:
            - 'tipo': 'MANUAL', 'MEDICO', 'PORCENTAJE', 'DESCONOCIDO'
            - 'confianza': 0.0 a 1.0
            - 'scores': diccionario con scores de cada clase
        """
        if pd.isna(texto) or str(texto).strip() == '':
            return {'tipo': 'VACIO', 'confianza': 1.0, 'scores': {}}

        texto = str(texto).strip()
        texto_upper = texto.upper()

        # 1. Reglas r√°pidas basadas en patrones
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        # Es un porcentaje o n√∫mero
        if re.match(r'^[+-]?[\d,\.%\s]+$', texto):
            return {'tipo': 'PORCENTAJE', 'confianza': 0.95, 'scores': {'porcentaje': 0.95}}

        # Contiene palabras clave de manual tarifario
        palabras_manual = ['SOAT', 'ISS', 'TARIFA', 'DECRETO', 'UVT', 'UVB', 'PROPIA', 'PROPIO', 'INSTITUCIONAL']
        for palabra in palabras_manual:
            if palabra in texto_upper:
                return {'tipo': 'MANUAL', 'confianza': 0.9, 'scores': {'manual': 0.9}}

        # Contiene palabras clave m√©dicas
        palabras_medicas = ['CONSULTA', 'TERAPIA', 'CIRUGIA', 'PROCEDIMIENTO', 'EXAMEN',
                           'TRATAMIENTO', 'BIOPSIA', 'ECOGRAFIA', 'LABORATORIO']
        for palabra in palabras_medicas:
            if palabra in texto_upper:
                return {'tipo': 'MEDICO', 'confianza': 0.85, 'scores': {'medico': 0.85}}

        # 2. Clasificaci√≥n ML con TF-IDF
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        try:
            vec_texto = self.vectorizer.transform([texto_upper])
            vec_array = np.asarray(vec_texto.todense()).flatten()

            # Calcular similitud con centroides
            sim_manual = cosine_similarity([vec_array], [self.centroide_manual])[0][0]
            sim_medico = cosine_similarity([vec_array], [self.centroide_medico])[0][0]

            # Normalizar scores
            total = sim_manual + sim_medico + 0.001
            score_manual = sim_manual / total
            score_medico = sim_medico / total

            scores = {'manual': score_manual, 'medico': score_medico}

            if score_manual > score_medico and score_manual > 0.4:
                return {'tipo': 'MANUAL', 'confianza': score_manual, 'scores': scores}
            elif score_medico > score_manual and score_medico > 0.4:
                return {'tipo': 'MEDICO', 'confianza': score_medico, 'scores': scores}
            else:
                return {'tipo': 'DESCONOCIDO', 'confianza': max(score_manual, score_medico), 'scores': scores}

        except Exception as e:
            return {'tipo': 'ERROR', 'confianza': 0.0, 'scores': {}, 'error': str(e)}

    def es_descripcion_medica(self, texto: str) -> Tuple[bool, float]:
        """
        Verifica si un texto parece ser una descripci√≥n m√©dica.

        Returns:
            (es_medico, confianza)
        """
        resultado = self.clasificar(texto)
        return resultado['tipo'] == 'MEDICO', resultado['confianza']

    def es_manual_tarifario(self, texto: str) -> Tuple[bool, float]:
        """
        Verifica si un texto parece ser un manual tarifario v√°lido.

        Returns:
            (es_manual, confianza)
        """
        resultado = self.clasificar(texto)
        return resultado['tipo'] == 'MANUAL', resultado['confianza']


# Crear instancia global
clasificador_ml = ClasificadorTextoMedico()

#@title 2.2 Probar el Clasificador ML { display-mode: "form" }
#@markdown ### üß™ **Prueba el clasificador con ejemplos**

print("="*70)
print("üß™ PRUEBAS DEL CLASIFICADOR ML")
print("="*70)

# Ejemplos de prueba
ejemplos = [
    # Manuales tarifarios
    "SOAT VIGENTE",
    "TARIFA PROPIA",
    "ISS 2001 + 80%",
    "DECRETO 2644 UVT",
    "TARIFAS INSTITUCIONALES",

    # Descripciones m√©dicas
    "CONSULTA DE MEDICINA GENERAL",
    "TERAPIA NEURAL POR SESION",
    "CIRUGIA DE RODILLA",
    "ECOGRAFIA ABDOMINAL",
    "LABORATORIO HEMOGRAMA",

    # Porcentajes
    "-30%",
    "0.05",
    "ISS + 65%",

    # Casos ambiguos
    "CONSULTA",
    "PROPIA",
    "VALORACION"
]

print(f"\n{'Texto':<45} {'Tipo':<12} {'Confianza':<10}")
print("‚îÄ"*70)

for ejemplo in ejemplos:
    resultado = clasificador_ml.clasificar(ejemplo)
    print(f"{ejemplo:<45} {resultado['tipo']:<12} {resultado['confianza']:.2f}")

#@title 3.1 Clase ETL con Machine Learning { display-mode: "form" }

class ETLConsolidadoT25_ML:
    """
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    ETL CONSOLIDADO T25 - VERSI√ìN CON MACHINE LEARNING
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    Sistema inteligente que detecta y corrige autom√°ticamente cuando:
    - manual_tarifario contiene descripciones m√©dicas
    - porcentaje_manual_tarifario contiene el manual real
    - Los valores est√°n intercambiados entre columnas
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    """

    ANOS_IGNORAR = {'1996', '2001', '2016', '2022', '2023', '2024', '2025', '2644', '2423', '780'}

    PATRON_NUMERO = re.compile(r'[+-]?\d+(?:[,\.]\d+)?')
    PATRON_PORCENTAJE_FINAL = re.compile(r'[+-]\s*(\d+(?:[,\.]\d+)?)\s*$')
    PATRON_MENOS = re.compile(r'MENOS\s*(\d+(?:[,\.]\d+)?)', re.IGNORECASE)
    PATRON_MAS = re.compile(r'(?:MAS|\+)\s*(\d+(?:[,\.]\d+)?)', re.IGNORECASE)
    PATRON_DECIMAL = re.compile(r'^(-?0\.\d+)$')

    def __init__(self, clasificador: ClasificadorTextoMedico, chunk_size: int = 50000):
        """Inicializa el ETL con el clasificador ML."""
        self.clasificador = clasificador
        self.chunk_size = chunk_size
        self.stats = {
            'total_registros': 0,
            'columnas_intercambiadas': 0,
            'manuales_normalizados': 0,
            'porcentajes_extraidos': 0,
            'anomalias_detectadas': [],
            'correcciones_ml': []
        }
        self.resultados = {}

    def _detectar_y_corregir_anomalia(self, row: pd.Series) -> Dict[str, Any]:
        """
        Detecta si hay anomal√≠a en la fila y sugiere correcci√≥n.

        Anomal√≠as detectadas:
        1. manual_tarifario tiene descripci√≥n m√©dica
        2. porcentaje_manual_tarifario tiene el manual real
        3. Valores intercambiados

        Returns:
            Dict con correcciones sugeridas
        """
        manual = str(row.get('manual_tarifario', '')).strip()
        porcentaje = str(row.get('porcentaje_manual_tarifario', '')).strip()
        descripcion = str(row.get('descripcion_del_cups', '')).strip()

        correccion = {
            'necesita_correccion': False,
            'nuevo_manual': manual,
            'nuevo_porcentaje': porcentaje,
            'razon': None,
            'confianza': 0.0
        }

        if not manual:
            return correccion

        # Clasificar el contenido de manual_tarifario
        clasif_manual = self.clasificador.clasificar(manual)
        clasif_porcentaje = self.clasificador.clasificar(porcentaje)

        # CASO 1: manual_tarifario tiene descripci√≥n m√©dica
        if clasif_manual['tipo'] == 'MEDICO' and clasif_manual['confianza'] > 0.6:
            # Verificar si porcentaje tiene el manual real
            if clasif_porcentaje['tipo'] == 'MANUAL' and clasif_porcentaje['confianza'] > 0.5:
                correccion['necesita_correccion'] = True
                correccion['nuevo_manual'] = porcentaje
                correccion['nuevo_porcentaje'] = '0'  # Extraer del nuevo manual si hay
                correccion['razon'] = f"ML detect√≥ descripci√≥n m√©dica en manual_tarifario (conf: {clasif_manual['confianza']:.2f})"
                correccion['confianza'] = clasif_manual['confianza']
                return correccion

        # CASO 2: manual_tarifario es similar a descripcion_del_cups
        if descripcion and len(manual) > 20:
            manual_words = set(manual.upper().split())
            desc_words = set(descripcion.upper().split())
            if len(manual_words) > 0 and len(desc_words) > 0:
                similitud = len(manual_words & desc_words) / min(len(manual_words), len(desc_words))
                if similitud > 0.5:  # M√°s del 50% de palabras en com√∫n
                    if clasif_porcentaje['tipo'] == 'MANUAL':
                        correccion['necesita_correccion'] = True
                        correccion['nuevo_manual'] = porcentaje
                        correccion['nuevo_porcentaje'] = '0'
                        correccion['razon'] = f"manual_tarifario similar a descripci√≥n ({similitud:.0%})"
                        correccion['confianza'] = similitud
                        return correccion

        # CASO 3: manual_tarifario tiene formato de tarifa (n√∫mero grande)
        try:
            valor_manual = float(manual.replace(',', '.').replace('$', '').strip())
            if valor_manual > 1000:  # Parece una tarifa, no un manual
                if clasif_porcentaje['tipo'] == 'MANUAL':
                    correccion['necesita_correccion'] = True
                    correccion['nuevo_manual'] = porcentaje
                    correccion['nuevo_porcentaje'] = '0'
                    correccion['razon'] = f"manual_tarifario contiene tarifa ({valor_manual:,.0f})"
                    correccion['confianza'] = 0.9
                    return correccion
        except:
            pass

        return correccion

    def _extraer_porcentaje(self, texto: str) -> Optional[float]:
        """Extrae porcentaje de forma inteligente."""
        if pd.isna(texto) or str(texto).strip() == '':
            return None

        texto = str(texto).strip()
        texto_upper = texto.upper()

        if 'PLENA' in texto_upper or 'PLENO' in texto_upper:
            if not re.search(r'[+-]\s*\d+', texto_upper):
                return 0.0

        texto_sin_pct = texto.replace('%', '')

        match = self.PATRON_PORCENTAJE_FINAL.search(texto_sin_pct)
        if match:
            try:
                valor = float(match.group(1).replace(',', '.'))
                if '-' in texto_sin_pct:
                    valor = -abs(valor)
                if -100 <= valor <= 200:
                    return valor
            except:
                pass

        match = self.PATRON_MENOS.search(texto_sin_pct)
        if match:
            try:
                return -float(match.group(1).replace(',', '.'))
            except:
                pass

        match = self.PATRON_MAS.search(texto_sin_pct)
        if match:
            try:
                return float(match.group(1).replace(',', '.'))
            except:
                pass

        match = self.PATRON_DECIMAL.match(texto_sin_pct.strip())
        if match:
            try:
                return round(float(match.group(1)) * 100, 2)
            except:
                pass

        numeros = self.PATRON_NUMERO.findall(texto_sin_pct)
        for num_str in reversed(numeros):
            try:
                num = float(num_str.replace(',', '.'))
                if str(int(abs(num))) in self.ANOS_IGNORAR:
                    continue
                if num > 1000:
                    continue
                if -100 <= num <= 200:
                    if 'MENOS' in texto_upper or f'-{num_str}' in texto:
                        num = -abs(num)
                    return num
            except:
                continue

        return None

    def _normalizar_manual(self, texto: str) -> str:
        """Normaliza el manual tarifario."""
        if pd.isna(texto) or str(texto).strip() == '':
            return 'PROPIO'

        texto = str(texto).strip()
        texto_upper = texto.upper()

        # PROPIO
        if re.search(r'\bPROPIA?S?\b|INSTITUCIONAL|TARIA\s*PROPIA', texto_upper):
            return 'PROPIO'

        # ISS
        if re.search(r'\bISS\b', texto_upper) and not re.search(r'\bSOAT\b', texto_upper):
            return 'ISS'

        # SOAT
        if re.search(r'\bSOAT\b|\bUVT\b|\bUVB\b|DECRETO\s*2423|DECRETO\s*2644', texto_upper):
            return 'SOAT'

        # N√∫meros puros -> PROPIO
        if re.match(r'^[\d,\.\s]+$', texto):
            return 'PROPIO'

        return texto

    def _procesar_fila(self, row: pd.Series) -> Dict[str, Any]:
        """
        Procesa una fila completa con detecci√≥n ML.
        """
        resultado = {
            'manual_tarifario': '',
            'porcentaje_manual_tarifario': 0.0,
            'correccion_aplicada': False,
            'log': None
        }

        # 1. Detectar anomal√≠as
        correccion = self._detectar_y_corregir_anomalia(row)

        if correccion['necesita_correccion']:
            # Usar valores corregidos
            manual_raw = correccion['nuevo_manual']
            porcentaje_raw = correccion['nuevo_porcentaje']
            resultado['correccion_aplicada'] = True
            resultado['log'] = correccion['razon']
        else:
            manual_raw = str(row.get('manual_tarifario', '')).strip()
            porcentaje_raw = str(row.get('porcentaje_manual_tarifario', '')).strip()

        # 2. Normalizar manual
        resultado['manual_tarifario'] = self._normalizar_manual(manual_raw)

        # 3. Extraer porcentaje
        tarifa = row.get('tarifa_unitaria_en_pesos', '0')
        try:
            tarifa_num = float(str(tarifa).replace(',', '.'))
        except:
            tarifa_num = 0

        # Si porcentaje es texto de manual o propio -> 0
        porcentaje_upper = porcentaje_raw.upper()
        if any(p in porcentaje_upper for p in ['PROPIO', 'PROPIA', 'INSTITUCIONAL', 'PLENA', 'PLENO']):
            resultado['porcentaje_manual_tarifario'] = 0.0
        else:
            # Extraer porcentaje
            pct = self._extraer_porcentaje(porcentaje_raw)
            if pct is not None:
                # Verificar que no sea igual a la tarifa
                if tarifa_num > 0 and abs(pct - tarifa_num) < 1:
                    resultado['porcentaje_manual_tarifario'] = 0.0
                elif pct > 1000:  # Probable tarifa duplicada
                    resultado['porcentaje_manual_tarifario'] = 0.0
                else:
                    resultado['porcentaje_manual_tarifario'] = round(pct, 2)
            else:
                resultado['porcentaje_manual_tarifario'] = 0.0

        return resultado

    def procesar_dataframe(self, df: pd.DataFrame, nombre: str = "Datos") -> pd.DataFrame:
        """Procesa un DataFrame completo."""
        print(f"\n{'‚ïê'*70}")
        print(f"üß† PROCESANDO CON ML: {nombre}")
        print(f"{'‚ïê'*70}")

        inicio = datetime.now()
        total = len(df)
        print(f"üìä Total registros: {total:,}")

        # Normalizar columnas
        df.columns = df.columns.str.strip().str.lower().str.replace(' ', '_')

        # Asegurar columnas
        for col in ['manual_tarifario', 'porcentaje_manual_tarifario', 'tarifa_unitaria_en_pesos']:
            if col not in df.columns:
                df[col] = ''

        # Procesar
        print(f"\nüîÑ Fase 1: Detecci√≥n de anomal√≠as con ML...")

        nuevos_manuales = []
        nuevos_porcentajes = []
        correcciones = []

        for idx in tqdm(range(total), desc="   Procesando"):
            row = df.iloc[idx]
            resultado = self._procesar_fila(row)

            nuevos_manuales.append(resultado['manual_tarifario'])
            nuevos_porcentajes.append(resultado['porcentaje_manual_tarifario'])

            if resultado['correccion_aplicada']:
                correcciones.append({
                    'indice': idx,
                    'original_manual': row.get('manual_tarifario', ''),
                    'original_porcentaje': row.get('porcentaje_manual_tarifario', ''),
                    'nuevo_manual': resultado['manual_tarifario'],
                    'log': resultado['log']
                })

        df['manual_tarifario'] = nuevos_manuales
        df['porcentaje_manual_tarifario'] = nuevos_porcentajes

        # Corregir tarifas
        print(f"\nüîÑ Fase 2: Corrigiendo tarifas...")
        tarifa = pd.to_numeric(
            df['tarifa_unitaria_en_pesos'].astype(str).str.replace(',', '.'),
            errors='coerce'
        ).fillna(0)
        mask_pequena = (tarifa > 0) & (tarifa < 100)
        tarifa.loc[mask_pequena] = tarifa.loc[mask_pequena] * 1000
        df['tarifa_unitaria_en_pesos'] = tarifa.round(2)

        # Estad√≠sticas
        duracion = (datetime.now() - inicio).total_seconds()

        print(f"\n{'‚îÄ'*70}")
        print(f"üìà RESULTADOS - {nombre}")
        print(f"{'‚îÄ'*70}")
        print(f"‚è±Ô∏è Tiempo: {duracion:.1f} segundos")
        print(f"üîß Correcciones ML aplicadas: {len(correcciones):,}")

        if correcciones:
            print(f"\nüìù Muestra de correcciones aplicadas:")
            for c in correcciones[:10]:
                print(f"   ‚Ä¢ Fila {c['indice']}: {c['log']}")
                print(f"     Original: '{str(c['original_manual'])[:40]}...'")
                print(f"     Corregido: '{c['nuevo_manual']}'")

        print(f"\nüìä Distribuci√≥n de Manuales:")
        for manual, count in df['manual_tarifario'].value_counts().head(10).items():
            pct = count / total * 100
            print(f"   {manual:15} ‚îÇ {count:>10,} ‚îÇ {pct:5.1f}%")

        self.stats['total_registros'] += total
        self.stats['columnas_intercambiadas'] += len(correcciones)
        self.stats['correcciones_ml'].extend(correcciones)

        gc.collect()
        return df

    def ejecutar(self, contenido: bytes, nombre: str) -> Dict[str, pd.DataFrame]:
        """Ejecuta el ETL completo."""
        print("\n" + "‚ïê"*70)
        print("üöÄ ETL CONSOLIDADO T25 - ML EDITION")
        print("‚ïê"*70)
        print(f"üìÅ Archivo: {nombre}")
        print(f"üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        inicio = datetime.now()

        # Cargar archivo
        dataframes = self._cargar_archivo(contenido, nombre)

        # Procesar cada hoja
        for nombre_hoja, df in dataframes.items():
            self.resultados[nombre_hoja] = self.procesar_dataframe(df, nombre_hoja)

        duracion = (datetime.now() - inicio).total_seconds()

        print("\n" + "‚ïê"*70)
        print("‚úÖ ETL ML COMPLETADO")
        print("‚ïê"*70)
        print(f"üìä Total registros: {self.stats['total_registros']:,}")
        print(f"üîß Correcciones ML: {self.stats['columnas_intercambiadas']:,}")
        print(f"‚è±Ô∏è Tiempo: {duracion:.1f} segundos")

        return self.resultados

    def _cargar_archivo(self, contenido: bytes, nombre: str) -> Dict[str, pd.DataFrame]:
        """Carga archivo Excel o CSV."""
        dataframes = {}

        if nombre.endswith('.csv'):
            resultado = chardet.detect(contenido[:10000])
            encoding = resultado['encoding'] or 'utf-8'

            for sep in [';', ',', '\t']:
                try:
                    df = pd.read_csv(io.BytesIO(contenido), sep=sep, encoding=encoding,
                                    dtype=str, low_memory=False)
                    if len(df.columns) > 1:
                        dataframes['Datos'] = df
                        break
                except:
                    continue
        else:
            excel = pd.ExcelFile(io.BytesIO(contenido))
            for hoja in excel.sheet_names:
                df = pd.read_excel(excel, sheet_name=hoja, dtype=str)
                if len(df) > 0:
                    dataframes[hoja] = df

        return dataframes

    def exportar_log_correcciones(self, archivo: str = 'correcciones_ml.csv'):
        """Exporta log de correcciones ML."""
        if self.stats['correcciones_ml']:
            df_log = pd.DataFrame(self.stats['correcciones_ml'])
            df_log.to_csv(archivo, index=False, encoding='utf-8-sig')
            print(f"‚úÖ Log exportado: {archivo}")
            return df_log
        else:
            print("‚ÑπÔ∏è No hay correcciones ML para exportar")
            return None


print("‚úÖ Clase ETLConsolidadoT25_ML definida")

#@title 4.1 Subir Archivo { display-mode: "form" }
#@markdown ### üìÅ **Sube tu archivo Excel o CSV**

print("="*70)
print("üì§ SUBIR ARCHIVO")
print("="*70)
print("\nFormatos soportados: .xlsx, .xls, .csv, .zip")
print()

uploaded = files.upload()

if uploaded:
    nombre_archivo = list(uploaded.keys())[0]
    contenido_archivo = uploaded[nombre_archivo]

    print(f"\n‚úÖ Archivo cargado: {nombre_archivo}")
    print(f"üì¶ Tama√±o: {len(contenido_archivo)/1024/1024:.2f} MB")

#@title 4.2 Ejecutar ETL con Machine Learning { display-mode: "form" }
#@markdown ### ‚öôÔ∏è **Procesa el archivo con detecci√≥n inteligente de anomal√≠as**

if 'contenido_archivo' not in dir():
    print("‚ùå ERROR: Primero sube un archivo")
else:
    # Crear ETL con clasificador ML
    etl_ml = ETLConsolidadoT25_ML(
        clasificador=clasificador_ml,
        chunk_size=50000
    )

    # Ejecutar
    dataframes_limpios = etl_ml.ejecutar(contenido_archivo, nombre_archivo)

    print("\nüì¶ DataFrames disponibles en: dataframes_limpios")

#@title 5.1 Ver Correcciones ML Aplicadas { display-mode: "form" }
#@markdown ### üîß **Muestra las correcciones detectadas por ML**

if 'etl_ml' not in dir():
    print("‚ùå ERROR: Primero ejecuta el ETL")
else:
    correcciones = etl_ml.stats['correcciones_ml']

    print("="*70)
    print("üîß CORRECCIONES ML APLICADAS")
    print("="*70)
    print(f"\nüìä Total correcciones: {len(correcciones):,}")

    if correcciones:
        print(f"\nüìù Detalle de correcciones:")
        print("‚îÄ"*70)

        for i, c in enumerate(correcciones[:50]):
            print(f"\n[{i+1}] Fila {c['indice']}")
            print(f"    üìå Raz√≥n: {c['log']}")
            print(f"    ‚ùå Original manual: {str(c['original_manual'])[:60]}")
            print(f"    ‚ùå Original %: {str(c['original_porcentaje'])[:40]}")
            print(f"    ‚úÖ Nuevo manual: {c['nuevo_manual']}")

        if len(correcciones) > 50:
            print(f"\n... y {len(correcciones) - 50} correcciones m√°s")
    else:
        print("\n‚úÖ No se detectaron anomal√≠as que requieran correcci√≥n ML")

#@title 5.2 Ver Resumen de Resultados { display-mode: "form" }

if 'dataframes_limpios' not in dir():
    print("‚ùå ERROR: Primero ejecuta el ETL")
else:
    print("="*70)
    print("üìä RESUMEN DE RESULTADOS")
    print("="*70)

    for nombre, df in dataframes_limpios.items():
        print(f"\n{'‚îÄ'*70}")
        print(f"üìë {nombre}: {len(df):,} registros")
        print(f"{'‚îÄ'*70}")

        print(f"\nüìã Manuales Tarifarios:")
        for val, count in df['manual_tarifario'].value_counts().items():
            pct = count / len(df) * 100
            barra = '‚ñà' * int(pct / 2)
            print(f"   {val:15} ‚îÇ {count:>10,} ‚îÇ {pct:5.1f}% ‚îÇ {barra}")

        print(f"\nüìä Top 10 Porcentajes:")
        for val, count in df['porcentaje_manual_tarifario'].value_counts().head(10).items():
            print(f"   {str(val):>10}% : {count:>10,}")

#@title 5.3 Ver Muestra de Datos { display-mode: "form" }

#@markdown Filas a mostrar:
n_filas = 25 #@param {type:"slider", min:5, max:100, step:5}

if 'dataframes_limpios' not in dir():
    print("‚ùå ERROR: Primero ejecuta el ETL")
else:
    for nombre, df in dataframes_limpios.items():
        print(f"\n{'‚ïê'*70}")
        print(f"üìë MUESTRA: {nombre}")
        print(f"{'‚ïê'*70}")

        cols = ['codigo_cups', 'descripcion_del_cups', 'tarifa_unitaria_en_pesos',
                'manual_tarifario', 'porcentaje_manual_tarifario', 'contrato']
        cols_disp = [c for c in cols if c in df.columns]

        display(df[cols_disp].head(n_filas))

#@title 6.1 Exportar a Excel { display-mode: "form" }

if 'dataframes_limpios' not in dir():
    print("‚ùå ERROR: Primero ejecuta el ETL")
else:
    print("="*70)
    print("üíæ EXPORTANDO A EXCEL")
    print("="*70)

    nombre_base = nombre_archivo.rsplit('.', 1)[0]
    archivo_excel = f"{nombre_base}_ML_LIMPIO.xlsx"

    print(f"\nüìù Generando: {archivo_excel}")

    with pd.ExcelWriter(archivo_excel, engine='xlsxwriter') as writer:
        workbook = writer.book

        fmt_header = workbook.add_format({
            'bold': True, 'bg_color': '#6A1B9A', 'font_color': 'white',
            'align': 'center', 'border': 1
        })
        fmt_moneda = workbook.add_format({'num_format': '$#,##0.00'})

        for nombre_hoja, df in tqdm(dataframes_limpios.items(), desc="Exportando"):
            hoja = nombre_hoja[:31]
            df.to_excel(writer, sheet_name=hoja, index=False, startrow=1, header=False)

            ws = writer.sheets[hoja]
            for col, column in enumerate(df.columns):
                ws.write(0, col, column, fmt_header)
                if column == 'tarifa_unitaria_en_pesos':
                    ws.set_column(col, col, 20, fmt_moneda)
                else:
                    ws.set_column(col, col, 15)

            ws.freeze_panes(1, 0)
            ws.autofilter(0, 0, len(df), len(df.columns) - 1)

    print(f"\n‚úÖ Excel generado: {archivo_excel}")

#@title 6.3 Descargar Archivos { display-mode: "form" }

print("üì• Descargando archivos...")

if 'archivo_excel' in dir() and os.path.exists(archivo_excel):
    print(f"\nüìä Descargando Excel: {archivo_excel}")
    files.download(archivo_excel)

if os.path.exists('correcciones_ml.csv'):
    print(f"\nüìù Descargando log ML: correcciones_ml.csv")
    files.download('correcciones_ml.csv')

print("\n‚úÖ Descargas iniciadas")
